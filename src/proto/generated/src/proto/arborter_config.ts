// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: src/proto/arborter_config.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";

export const protobufPackage = "xyz.aspens.arborter_config.v1";

export enum BaseOrQuote {
  BASE_OR_QUOTE_UNSPECIFIED = 0,
  BASE_OR_QUOTE_BASE = 1,
  BASE_OR_QUOTE_QUOTE = 2,
  UNRECOGNIZED = -1,
}

export function baseOrQuoteFromJSON(object: any): BaseOrQuote {
  switch (object) {
    case 0:
    case "BASE_OR_QUOTE_UNSPECIFIED":
      return BaseOrQuote.BASE_OR_QUOTE_UNSPECIFIED;
    case 1:
    case "BASE_OR_QUOTE_BASE":
      return BaseOrQuote.BASE_OR_QUOTE_BASE;
    case 2:
    case "BASE_OR_QUOTE_QUOTE":
      return BaseOrQuote.BASE_OR_QUOTE_QUOTE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BaseOrQuote.UNRECOGNIZED;
  }
}

export function baseOrQuoteToJSON(object: BaseOrQuote): string {
  switch (object) {
    case BaseOrQuote.BASE_OR_QUOTE_UNSPECIFIED:
      return "BASE_OR_QUOTE_UNSPECIFIED";
    case BaseOrQuote.BASE_OR_QUOTE_BASE:
      return "BASE_OR_QUOTE_BASE";
    case BaseOrQuote.BASE_OR_QUOTE_QUOTE:
      return "BASE_OR_QUOTE_QUOTE";
    case BaseOrQuote.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface DeployContractRequest {
  /** The name of the chain to deploy the contract on. e.g. base-sepolia */
  chainNetwork: string;
  /** designate whether to deploy the contract on the base or quote chain */
  baseOrQuote: string;
}

export interface DeployContractResponse {
  /** The address that the contract is deployed to on the base chain. */
  baseAddress: string;
  /** The address that the contract is deployed to on the quote chain. */
  quoteAddress: string;
}

export interface AddChainRequest {
  /** The chain to add */
  chain: Chain | undefined;
}

export interface AddChainResponse {
  /** Indicates if the chain was added successfully */
  success: boolean;
  /** The configuration object */
  config: Configuration | undefined;
}

export interface AddTokenRequest {
  /** The name of the chain to add the token to. e.g. base-sepolia */
  chainNetwork: string;
  /** The token to ad */
  token: Token | undefined;
}

export interface AddTokenResponse {
  /** Indicates if the token was added successfully */
  success: boolean;
  /** The configuration object */
  config: Configuration | undefined;
}

export interface AddMarketRequest {
  /** The base chain network */
  baseChainNetwork: string;
  /** The quote chain network */
  quoteChainNetwork: string;
  /** The base chain token symbol */
  baseChainTokenSymbol: string;
  /** The quote chain token symbol */
  quoteChainTokenSymbol: string;
  /** The base chain token address */
  baseChainTokenAddress: string;
  /** The quote chain token address */
  quoteChainTokenAddress: string;
  /** The base chain token decimals */
  baseChainTokenDecimals: number;
  /** The quote chain token decimals */
  quoteChainTokenDecimals: number;
  /** The pair decimals (this is chosen by the stack admin) */
  pairDecimals: number;
}

export interface AddMarketResponse {
  /** Indicates if the market was added successfully */
  success: boolean;
  /** The configuration object */
  config: Configuration | undefined;
}

export interface AddTradeContractRequest {
  /** The chain address of the trade contract */
  address: string;
  /** The chain ID to associate the trade contract with */
  chainId: number;
}

export interface AddTradeContractResponse {
  /** The created trade contract */
  tradeContract: TradeContract | undefined;
}

/** Request message for the service */
export interface GetConfigRequest {
}

export interface GetConfigResponse {
  /** The configuration object */
  config: Configuration | undefined;
}

/** The top-level response containing chains and markets */
export interface Configuration {
  /** List of supported chains */
  chains: Chain[];
  /** List of supported markets */
  markets: Market[];
}

/** Represents the trade contract details */
export interface TradeContract {
  /** Optional: For non-EVM chains like Hedera, Solana, etc. */
  contractId?:
    | string
    | undefined;
  /** The chain address of the trade contract */
  address: string;
}

/** Represents a single blockchain network */
export interface Chain {
  /** The architecture of the chain (e.g., EVM, Hedera) */
  architecture: string;
  /** The canonical name of the chain (e.g., 'Ethereum Mainnet' | 'Hedera Testnet') */
  canonicalName: string;
  /** The chain network (e.g., op-mainnet, hedera-testnet) */
  network: string;
  /** The chain ID (e.g., Ethereum = 1) */
  chainId: number;
  /** Pubkey address of the owner of the deployed trade contract */
  contractOwnerAddress: string;
  /** Optional: URL to the chain explorer */
  explorerUrl?:
    | string
    | undefined;
  /** The RPC URL for the chain */
  rpcUrl: string;
  /** The address of the factory service contract on this chain. This is the address to call to deploy a new trade contract */
  serviceAddress: string;
  /** The trade contract details */
  tradeContract:
    | TradeContract
    | undefined;
  /** Mapping of token symbols to token details */
  tokens: { [key: string]: Token };
  /** Declare whether this chain should act as the base or quote side of the trading pairs */
  baseOrQuote: BaseOrQuote;
}

export interface Chain_TokensEntry {
  key: string;
  value: Token | undefined;
}

/** Represents a market with a base- and quote- chain token pair */
export interface Market {
  /** The market slug, e.g. 'base-sepolia-usdc--op-sepolia-usdc' */
  slug: string;
  /** The market name, e.g. 'Base Sepolia USDC - OP Sepolia USDC' */
  name: string;
  /** The base chain, e.g. 'base-sepolia' */
  baseChainNetwork: string;
  /** The quote chain, e.g. 'op-sepolia' */
  quoteChainNetwork: string;
  /** / The token symbol for the base chain */
  baseChainTokenSymbol: string;
  /** / The token symbol for the quote chain */
  quoteChainTokenSymbol: string;
  /** The base chain token decimals */
  baseChainTokenDecimals: number;
  /** The quote chain token decimals */
  quoteChainTokenDecimals: number;
  /** The pair decimals (this is chosen by the stack admin) */
  pairDecimals: number;
  /** Identity the market: concat(base_chain_id "::" token_address "::" quote_chain_id "::" token_address) */
  marketId?: string | undefined;
}

/** Represents a single token */
export interface Token {
  /** The name of the token */
  name: string;
  /** The symbol of the token */
  symbol: string;
  /** The chain address of the token contract */
  address: string;
  /** Optional: for networks that use IDs (e.g., Hedera) */
  tokenId?:
    | string
    | undefined;
  /** The number of decimal places the token is defined with */
  decimals: number;
  /** The level of precision the token trades at */
  tradePrecision: number;
}

/** Delete market request */
export interface DeleteMarketRequest {
  /** The market ID to delete */
  marketId: string;
}

/** Delete market response */
export interface DeleteMarketResponse {
  /** Indicates if the market was deleted successfully */
  success: boolean;
  /** The configuration object after deletion */
  config: Configuration | undefined;
}

/** Delete token request */
export interface DeleteTokenRequest {
  /** The chain network where the token exists */
  chainNetwork: string;
  /** The token symbol to delete */
  tokenSymbol: string;
}

/** Delete token response */
export interface DeleteTokenResponse {
  /** Indicates if the token was deleted successfully */
  success: boolean;
  /** The configuration object after deletion */
  config: Configuration | undefined;
}

/** Delete chain request */
export interface DeleteChainRequest {
  /** The chain network to delete */
  chainNetwork: string;
}

/** Delete chain response */
export interface DeleteChainResponse {
  /** Indicates if the chain was deleted successfully */
  success: boolean;
  /** The configuration object after deletion */
  config: Configuration | undefined;
}

/** Delete trade contract request */
export interface DeleteTradeContractRequest {
  /** The chain ID to delete the trade contract from */
  chainId: number;
}

/** Delete trade contract response */
export interface DeleteTradeContractResponse {
  /** Indicates if the trade contract was deleted successfully */
  success: boolean;
  /** The configuration object after deletion */
  config: Configuration | undefined;
}

export interface Empty {
}

/** Version information in vergen style */
export interface VersionInfo {
  /** The version of the application (e.g., "1.0.0") */
  version: string;
  /** The git commit hash */
  gitCommitHash: string;
  /** The git commit date */
  gitCommitDate: string;
  /** The git branch name */
  gitBranch: string;
  /** The build timestamp */
  buildTimestamp: string;
  /** The target triple */
  targetTriple: string;
  /** The rustc version used to build */
  rustcVersion: string;
  /** The cargo features enabled */
  cargoFeatures: string[];
}

function createBaseDeployContractRequest(): DeployContractRequest {
  return { chainNetwork: "", baseOrQuote: "" };
}

export const DeployContractRequest = {
  encode(message: DeployContractRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chainNetwork !== "") {
      writer.uint32(10).string(message.chainNetwork);
    }
    if (message.baseOrQuote !== "") {
      writer.uint32(18).string(message.baseOrQuote);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeployContractRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployContractRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chainNetwork = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.baseOrQuote = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployContractRequest {
    return {
      chainNetwork: isSet(object.chainNetwork) ? globalThis.String(object.chainNetwork) : "",
      baseOrQuote: isSet(object.baseOrQuote) ? globalThis.String(object.baseOrQuote) : "",
    };
  },

  toJSON(message: DeployContractRequest): unknown {
    const obj: any = {};
    if (message.chainNetwork !== "") {
      obj.chainNetwork = message.chainNetwork;
    }
    if (message.baseOrQuote !== "") {
      obj.baseOrQuote = message.baseOrQuote;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeployContractRequest>, I>>(base?: I): DeployContractRequest {
    return DeployContractRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeployContractRequest>, I>>(object: I): DeployContractRequest {
    const message = createBaseDeployContractRequest();
    message.chainNetwork = object.chainNetwork ?? "";
    message.baseOrQuote = object.baseOrQuote ?? "";
    return message;
  },
};

function createBaseDeployContractResponse(): DeployContractResponse {
  return { baseAddress: "", quoteAddress: "" };
}

export const DeployContractResponse = {
  encode(message: DeployContractResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.baseAddress !== "") {
      writer.uint32(10).string(message.baseAddress);
    }
    if (message.quoteAddress !== "") {
      writer.uint32(18).string(message.quoteAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeployContractResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployContractResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.baseAddress = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.quoteAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployContractResponse {
    return {
      baseAddress: isSet(object.baseAddress) ? globalThis.String(object.baseAddress) : "",
      quoteAddress: isSet(object.quoteAddress) ? globalThis.String(object.quoteAddress) : "",
    };
  },

  toJSON(message: DeployContractResponse): unknown {
    const obj: any = {};
    if (message.baseAddress !== "") {
      obj.baseAddress = message.baseAddress;
    }
    if (message.quoteAddress !== "") {
      obj.quoteAddress = message.quoteAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeployContractResponse>, I>>(base?: I): DeployContractResponse {
    return DeployContractResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeployContractResponse>, I>>(object: I): DeployContractResponse {
    const message = createBaseDeployContractResponse();
    message.baseAddress = object.baseAddress ?? "";
    message.quoteAddress = object.quoteAddress ?? "";
    return message;
  },
};

function createBaseAddChainRequest(): AddChainRequest {
  return { chain: undefined };
}

export const AddChainRequest = {
  encode(message: AddChainRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chain !== undefined) {
      Chain.encode(message.chain, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddChainRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddChainRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chain = Chain.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddChainRequest {
    return { chain: isSet(object.chain) ? Chain.fromJSON(object.chain) : undefined };
  },

  toJSON(message: AddChainRequest): unknown {
    const obj: any = {};
    if (message.chain !== undefined) {
      obj.chain = Chain.toJSON(message.chain);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddChainRequest>, I>>(base?: I): AddChainRequest {
    return AddChainRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddChainRequest>, I>>(object: I): AddChainRequest {
    const message = createBaseAddChainRequest();
    message.chain = (object.chain !== undefined && object.chain !== null) ? Chain.fromPartial(object.chain) : undefined;
    return message;
  },
};

function createBaseAddChainResponse(): AddChainResponse {
  return { success: false, config: undefined };
}

export const AddChainResponse = {
  encode(message: AddChainResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.config !== undefined) {
      Configuration.encode(message.config, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddChainResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddChainResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.config = Configuration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddChainResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      config: isSet(object.config) ? Configuration.fromJSON(object.config) : undefined,
    };
  },

  toJSON(message: AddChainResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.config !== undefined) {
      obj.config = Configuration.toJSON(message.config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddChainResponse>, I>>(base?: I): AddChainResponse {
    return AddChainResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddChainResponse>, I>>(object: I): AddChainResponse {
    const message = createBaseAddChainResponse();
    message.success = object.success ?? false;
    message.config = (object.config !== undefined && object.config !== null)
      ? Configuration.fromPartial(object.config)
      : undefined;
    return message;
  },
};

function createBaseAddTokenRequest(): AddTokenRequest {
  return { chainNetwork: "", token: undefined };
}

export const AddTokenRequest = {
  encode(message: AddTokenRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chainNetwork !== "") {
      writer.uint32(10).string(message.chainNetwork);
    }
    if (message.token !== undefined) {
      Token.encode(message.token, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddTokenRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chainNetwork = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.token = Token.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddTokenRequest {
    return {
      chainNetwork: isSet(object.chainNetwork) ? globalThis.String(object.chainNetwork) : "",
      token: isSet(object.token) ? Token.fromJSON(object.token) : undefined,
    };
  },

  toJSON(message: AddTokenRequest): unknown {
    const obj: any = {};
    if (message.chainNetwork !== "") {
      obj.chainNetwork = message.chainNetwork;
    }
    if (message.token !== undefined) {
      obj.token = Token.toJSON(message.token);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddTokenRequest>, I>>(base?: I): AddTokenRequest {
    return AddTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddTokenRequest>, I>>(object: I): AddTokenRequest {
    const message = createBaseAddTokenRequest();
    message.chainNetwork = object.chainNetwork ?? "";
    message.token = (object.token !== undefined && object.token !== null) ? Token.fromPartial(object.token) : undefined;
    return message;
  },
};

function createBaseAddTokenResponse(): AddTokenResponse {
  return { success: false, config: undefined };
}

export const AddTokenResponse = {
  encode(message: AddTokenResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.config !== undefined) {
      Configuration.encode(message.config, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddTokenResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.config = Configuration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddTokenResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      config: isSet(object.config) ? Configuration.fromJSON(object.config) : undefined,
    };
  },

  toJSON(message: AddTokenResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.config !== undefined) {
      obj.config = Configuration.toJSON(message.config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddTokenResponse>, I>>(base?: I): AddTokenResponse {
    return AddTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddTokenResponse>, I>>(object: I): AddTokenResponse {
    const message = createBaseAddTokenResponse();
    message.success = object.success ?? false;
    message.config = (object.config !== undefined && object.config !== null)
      ? Configuration.fromPartial(object.config)
      : undefined;
    return message;
  },
};

function createBaseAddMarketRequest(): AddMarketRequest {
  return {
    baseChainNetwork: "",
    quoteChainNetwork: "",
    baseChainTokenSymbol: "",
    quoteChainTokenSymbol: "",
    baseChainTokenAddress: "",
    quoteChainTokenAddress: "",
    baseChainTokenDecimals: 0,
    quoteChainTokenDecimals: 0,
    pairDecimals: 0,
  };
}

export const AddMarketRequest = {
  encode(message: AddMarketRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.baseChainNetwork !== "") {
      writer.uint32(10).string(message.baseChainNetwork);
    }
    if (message.quoteChainNetwork !== "") {
      writer.uint32(18).string(message.quoteChainNetwork);
    }
    if (message.baseChainTokenSymbol !== "") {
      writer.uint32(26).string(message.baseChainTokenSymbol);
    }
    if (message.quoteChainTokenSymbol !== "") {
      writer.uint32(34).string(message.quoteChainTokenSymbol);
    }
    if (message.baseChainTokenAddress !== "") {
      writer.uint32(42).string(message.baseChainTokenAddress);
    }
    if (message.quoteChainTokenAddress !== "") {
      writer.uint32(50).string(message.quoteChainTokenAddress);
    }
    if (message.baseChainTokenDecimals !== 0) {
      writer.uint32(56).int32(message.baseChainTokenDecimals);
    }
    if (message.quoteChainTokenDecimals !== 0) {
      writer.uint32(64).int32(message.quoteChainTokenDecimals);
    }
    if (message.pairDecimals !== 0) {
      writer.uint32(72).int32(message.pairDecimals);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddMarketRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddMarketRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.baseChainNetwork = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.quoteChainNetwork = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.baseChainTokenSymbol = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.quoteChainTokenSymbol = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.baseChainTokenAddress = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.quoteChainTokenAddress = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.baseChainTokenDecimals = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.quoteChainTokenDecimals = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.pairDecimals = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddMarketRequest {
    return {
      baseChainNetwork: isSet(object.baseChainNetwork) ? globalThis.String(object.baseChainNetwork) : "",
      quoteChainNetwork: isSet(object.quoteChainNetwork) ? globalThis.String(object.quoteChainNetwork) : "",
      baseChainTokenSymbol: isSet(object.baseChainTokenSymbol) ? globalThis.String(object.baseChainTokenSymbol) : "",
      quoteChainTokenSymbol: isSet(object.quoteChainTokenSymbol) ? globalThis.String(object.quoteChainTokenSymbol) : "",
      baseChainTokenAddress: isSet(object.baseChainTokenAddress) ? globalThis.String(object.baseChainTokenAddress) : "",
      quoteChainTokenAddress: isSet(object.quoteChainTokenAddress)
        ? globalThis.String(object.quoteChainTokenAddress)
        : "",
      baseChainTokenDecimals: isSet(object.baseChainTokenDecimals)
        ? globalThis.Number(object.baseChainTokenDecimals)
        : 0,
      quoteChainTokenDecimals: isSet(object.quoteChainTokenDecimals)
        ? globalThis.Number(object.quoteChainTokenDecimals)
        : 0,
      pairDecimals: isSet(object.pairDecimals) ? globalThis.Number(object.pairDecimals) : 0,
    };
  },

  toJSON(message: AddMarketRequest): unknown {
    const obj: any = {};
    if (message.baseChainNetwork !== "") {
      obj.baseChainNetwork = message.baseChainNetwork;
    }
    if (message.quoteChainNetwork !== "") {
      obj.quoteChainNetwork = message.quoteChainNetwork;
    }
    if (message.baseChainTokenSymbol !== "") {
      obj.baseChainTokenSymbol = message.baseChainTokenSymbol;
    }
    if (message.quoteChainTokenSymbol !== "") {
      obj.quoteChainTokenSymbol = message.quoteChainTokenSymbol;
    }
    if (message.baseChainTokenAddress !== "") {
      obj.baseChainTokenAddress = message.baseChainTokenAddress;
    }
    if (message.quoteChainTokenAddress !== "") {
      obj.quoteChainTokenAddress = message.quoteChainTokenAddress;
    }
    if (message.baseChainTokenDecimals !== 0) {
      obj.baseChainTokenDecimals = Math.round(message.baseChainTokenDecimals);
    }
    if (message.quoteChainTokenDecimals !== 0) {
      obj.quoteChainTokenDecimals = Math.round(message.quoteChainTokenDecimals);
    }
    if (message.pairDecimals !== 0) {
      obj.pairDecimals = Math.round(message.pairDecimals);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddMarketRequest>, I>>(base?: I): AddMarketRequest {
    return AddMarketRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddMarketRequest>, I>>(object: I): AddMarketRequest {
    const message = createBaseAddMarketRequest();
    message.baseChainNetwork = object.baseChainNetwork ?? "";
    message.quoteChainNetwork = object.quoteChainNetwork ?? "";
    message.baseChainTokenSymbol = object.baseChainTokenSymbol ?? "";
    message.quoteChainTokenSymbol = object.quoteChainTokenSymbol ?? "";
    message.baseChainTokenAddress = object.baseChainTokenAddress ?? "";
    message.quoteChainTokenAddress = object.quoteChainTokenAddress ?? "";
    message.baseChainTokenDecimals = object.baseChainTokenDecimals ?? 0;
    message.quoteChainTokenDecimals = object.quoteChainTokenDecimals ?? 0;
    message.pairDecimals = object.pairDecimals ?? 0;
    return message;
  },
};

function createBaseAddMarketResponse(): AddMarketResponse {
  return { success: false, config: undefined };
}

export const AddMarketResponse = {
  encode(message: AddMarketResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.config !== undefined) {
      Configuration.encode(message.config, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddMarketResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddMarketResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.config = Configuration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddMarketResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      config: isSet(object.config) ? Configuration.fromJSON(object.config) : undefined,
    };
  },

  toJSON(message: AddMarketResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.config !== undefined) {
      obj.config = Configuration.toJSON(message.config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddMarketResponse>, I>>(base?: I): AddMarketResponse {
    return AddMarketResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddMarketResponse>, I>>(object: I): AddMarketResponse {
    const message = createBaseAddMarketResponse();
    message.success = object.success ?? false;
    message.config = (object.config !== undefined && object.config !== null)
      ? Configuration.fromPartial(object.config)
      : undefined;
    return message;
  },
};

function createBaseAddTradeContractRequest(): AddTradeContractRequest {
  return { address: "", chainId: 0 };
}

export const AddTradeContractRequest = {
  encode(message: AddTradeContractRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.chainId !== 0) {
      writer.uint32(16).int32(message.chainId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddTradeContractRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddTradeContractRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.chainId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddTradeContractRequest {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      chainId: isSet(object.chainId) ? globalThis.Number(object.chainId) : 0,
    };
  },

  toJSON(message: AddTradeContractRequest): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.chainId !== 0) {
      obj.chainId = Math.round(message.chainId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddTradeContractRequest>, I>>(base?: I): AddTradeContractRequest {
    return AddTradeContractRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddTradeContractRequest>, I>>(object: I): AddTradeContractRequest {
    const message = createBaseAddTradeContractRequest();
    message.address = object.address ?? "";
    message.chainId = object.chainId ?? 0;
    return message;
  },
};

function createBaseAddTradeContractResponse(): AddTradeContractResponse {
  return { tradeContract: undefined };
}

export const AddTradeContractResponse = {
  encode(message: AddTradeContractResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tradeContract !== undefined) {
      TradeContract.encode(message.tradeContract, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddTradeContractResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddTradeContractResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tradeContract = TradeContract.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddTradeContractResponse {
    return { tradeContract: isSet(object.tradeContract) ? TradeContract.fromJSON(object.tradeContract) : undefined };
  },

  toJSON(message: AddTradeContractResponse): unknown {
    const obj: any = {};
    if (message.tradeContract !== undefined) {
      obj.tradeContract = TradeContract.toJSON(message.tradeContract);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddTradeContractResponse>, I>>(base?: I): AddTradeContractResponse {
    return AddTradeContractResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddTradeContractResponse>, I>>(object: I): AddTradeContractResponse {
    const message = createBaseAddTradeContractResponse();
    message.tradeContract = (object.tradeContract !== undefined && object.tradeContract !== null)
      ? TradeContract.fromPartial(object.tradeContract)
      : undefined;
    return message;
  },
};

function createBaseGetConfigRequest(): GetConfigRequest {
  return {};
}

export const GetConfigRequest = {
  encode(_: GetConfigRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetConfigRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetConfigRequest {
    return {};
  },

  toJSON(_: GetConfigRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetConfigRequest>, I>>(base?: I): GetConfigRequest {
    return GetConfigRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetConfigRequest>, I>>(_: I): GetConfigRequest {
    const message = createBaseGetConfigRequest();
    return message;
  },
};

function createBaseGetConfigResponse(): GetConfigResponse {
  return { config: undefined };
}

export const GetConfigResponse = {
  encode(message: GetConfigResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.config !== undefined) {
      Configuration.encode(message.config, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetConfigResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConfigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.config = Configuration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConfigResponse {
    return { config: isSet(object.config) ? Configuration.fromJSON(object.config) : undefined };
  },

  toJSON(message: GetConfigResponse): unknown {
    const obj: any = {};
    if (message.config !== undefined) {
      obj.config = Configuration.toJSON(message.config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetConfigResponse>, I>>(base?: I): GetConfigResponse {
    return GetConfigResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetConfigResponse>, I>>(object: I): GetConfigResponse {
    const message = createBaseGetConfigResponse();
    message.config = (object.config !== undefined && object.config !== null)
      ? Configuration.fromPartial(object.config)
      : undefined;
    return message;
  },
};

function createBaseConfiguration(): Configuration {
  return { chains: [], markets: [] };
}

export const Configuration = {
  encode(message: Configuration, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.chains) {
      Chain.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.markets) {
      Market.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Configuration {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfiguration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chains.push(Chain.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.markets.push(Market.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Configuration {
    return {
      chains: globalThis.Array.isArray(object?.chains) ? object.chains.map((e: any) => Chain.fromJSON(e)) : [],
      markets: globalThis.Array.isArray(object?.markets) ? object.markets.map((e: any) => Market.fromJSON(e)) : [],
    };
  },

  toJSON(message: Configuration): unknown {
    const obj: any = {};
    if (message.chains?.length) {
      obj.chains = message.chains.map((e) => Chain.toJSON(e));
    }
    if (message.markets?.length) {
      obj.markets = message.markets.map((e) => Market.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Configuration>, I>>(base?: I): Configuration {
    return Configuration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Configuration>, I>>(object: I): Configuration {
    const message = createBaseConfiguration();
    message.chains = object.chains?.map((e) => Chain.fromPartial(e)) || [];
    message.markets = object.markets?.map((e) => Market.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTradeContract(): TradeContract {
  return { contractId: undefined, address: "" };
}

export const TradeContract = {
  encode(message: TradeContract, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contractId !== undefined) {
      writer.uint32(10).string(message.contractId);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TradeContract {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTradeContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contractId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TradeContract {
    return {
      contractId: isSet(object.contractId) ? globalThis.String(object.contractId) : undefined,
      address: isSet(object.address) ? globalThis.String(object.address) : "",
    };
  },

  toJSON(message: TradeContract): unknown {
    const obj: any = {};
    if (message.contractId !== undefined) {
      obj.contractId = message.contractId;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TradeContract>, I>>(base?: I): TradeContract {
    return TradeContract.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TradeContract>, I>>(object: I): TradeContract {
    const message = createBaseTradeContract();
    message.contractId = object.contractId ?? undefined;
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseChain(): Chain {
  return {
    architecture: "",
    canonicalName: "",
    network: "",
    chainId: 0,
    contractOwnerAddress: "",
    explorerUrl: undefined,
    rpcUrl: "",
    serviceAddress: "",
    tradeContract: undefined,
    tokens: {},
    baseOrQuote: 0,
  };
}

export const Chain = {
  encode(message: Chain, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.architecture !== "") {
      writer.uint32(10).string(message.architecture);
    }
    if (message.canonicalName !== "") {
      writer.uint32(18).string(message.canonicalName);
    }
    if (message.network !== "") {
      writer.uint32(26).string(message.network);
    }
    if (message.chainId !== 0) {
      writer.uint32(32).int32(message.chainId);
    }
    if (message.contractOwnerAddress !== "") {
      writer.uint32(42).string(message.contractOwnerAddress);
    }
    if (message.explorerUrl !== undefined) {
      writer.uint32(50).string(message.explorerUrl);
    }
    if (message.rpcUrl !== "") {
      writer.uint32(58).string(message.rpcUrl);
    }
    if (message.serviceAddress !== "") {
      writer.uint32(66).string(message.serviceAddress);
    }
    if (message.tradeContract !== undefined) {
      TradeContract.encode(message.tradeContract, writer.uint32(74).fork()).ldelim();
    }
    Object.entries(message.tokens).forEach(([key, value]) => {
      Chain_TokensEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).ldelim();
    });
    if (message.baseOrQuote !== 0) {
      writer.uint32(88).int32(message.baseOrQuote);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Chain {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.architecture = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.canonicalName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.network = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.chainId = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.contractOwnerAddress = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.explorerUrl = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.rpcUrl = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.serviceAddress = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.tradeContract = TradeContract.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          const entry10 = Chain_TokensEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.tokens[entry10.key] = entry10.value;
          }
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.baseOrQuote = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Chain {
    return {
      architecture: isSet(object.architecture) ? globalThis.String(object.architecture) : "",
      canonicalName: isSet(object.canonicalName) ? globalThis.String(object.canonicalName) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      chainId: isSet(object.chainId) ? globalThis.Number(object.chainId) : 0,
      contractOwnerAddress: isSet(object.contractOwnerAddress) ? globalThis.String(object.contractOwnerAddress) : "",
      explorerUrl: isSet(object.explorerUrl) ? globalThis.String(object.explorerUrl) : undefined,
      rpcUrl: isSet(object.rpcUrl) ? globalThis.String(object.rpcUrl) : "",
      serviceAddress: isSet(object.serviceAddress) ? globalThis.String(object.serviceAddress) : "",
      tradeContract: isSet(object.tradeContract) ? TradeContract.fromJSON(object.tradeContract) : undefined,
      tokens: isObject(object.tokens)
        ? Object.entries(object.tokens).reduce<{ [key: string]: Token }>((acc, [key, value]) => {
          acc[key] = Token.fromJSON(value);
          return acc;
        }, {})
        : {},
      baseOrQuote: isSet(object.baseOrQuote) ? baseOrQuoteFromJSON(object.baseOrQuote) : 0,
    };
  },

  toJSON(message: Chain): unknown {
    const obj: any = {};
    if (message.architecture !== "") {
      obj.architecture = message.architecture;
    }
    if (message.canonicalName !== "") {
      obj.canonicalName = message.canonicalName;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.chainId !== 0) {
      obj.chainId = Math.round(message.chainId);
    }
    if (message.contractOwnerAddress !== "") {
      obj.contractOwnerAddress = message.contractOwnerAddress;
    }
    if (message.explorerUrl !== undefined) {
      obj.explorerUrl = message.explorerUrl;
    }
    if (message.rpcUrl !== "") {
      obj.rpcUrl = message.rpcUrl;
    }
    if (message.serviceAddress !== "") {
      obj.serviceAddress = message.serviceAddress;
    }
    if (message.tradeContract !== undefined) {
      obj.tradeContract = TradeContract.toJSON(message.tradeContract);
    }
    if (message.tokens) {
      const entries = Object.entries(message.tokens);
      if (entries.length > 0) {
        obj.tokens = {};
        entries.forEach(([k, v]) => {
          obj.tokens[k] = Token.toJSON(v);
        });
      }
    }
    if (message.baseOrQuote !== 0) {
      obj.baseOrQuote = baseOrQuoteToJSON(message.baseOrQuote);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Chain>, I>>(base?: I): Chain {
    return Chain.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Chain>, I>>(object: I): Chain {
    const message = createBaseChain();
    message.architecture = object.architecture ?? "";
    message.canonicalName = object.canonicalName ?? "";
    message.network = object.network ?? "";
    message.chainId = object.chainId ?? 0;
    message.contractOwnerAddress = object.contractOwnerAddress ?? "";
    message.explorerUrl = object.explorerUrl ?? undefined;
    message.rpcUrl = object.rpcUrl ?? "";
    message.serviceAddress = object.serviceAddress ?? "";
    message.tradeContract = (object.tradeContract !== undefined && object.tradeContract !== null)
      ? TradeContract.fromPartial(object.tradeContract)
      : undefined;
    message.tokens = Object.entries(object.tokens ?? {}).reduce<{ [key: string]: Token }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Token.fromPartial(value);
      }
      return acc;
    }, {});
    message.baseOrQuote = object.baseOrQuote ?? 0;
    return message;
  },
};

function createBaseChain_TokensEntry(): Chain_TokensEntry {
  return { key: "", value: undefined };
}

export const Chain_TokensEntry = {
  encode(message: Chain_TokensEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Token.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Chain_TokensEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChain_TokensEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Token.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Chain_TokensEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Token.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Chain_TokensEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Token.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Chain_TokensEntry>, I>>(base?: I): Chain_TokensEntry {
    return Chain_TokensEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Chain_TokensEntry>, I>>(object: I): Chain_TokensEntry {
    const message = createBaseChain_TokensEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Token.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseMarket(): Market {
  return {
    slug: "",
    name: "",
    baseChainNetwork: "",
    quoteChainNetwork: "",
    baseChainTokenSymbol: "",
    quoteChainTokenSymbol: "",
    baseChainTokenDecimals: 0,
    quoteChainTokenDecimals: 0,
    pairDecimals: 0,
    marketId: undefined,
  };
}

export const Market = {
  encode(message: Market, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.slug !== "") {
      writer.uint32(10).string(message.slug);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.baseChainNetwork !== "") {
      writer.uint32(26).string(message.baseChainNetwork);
    }
    if (message.quoteChainNetwork !== "") {
      writer.uint32(34).string(message.quoteChainNetwork);
    }
    if (message.baseChainTokenSymbol !== "") {
      writer.uint32(42).string(message.baseChainTokenSymbol);
    }
    if (message.quoteChainTokenSymbol !== "") {
      writer.uint32(50).string(message.quoteChainTokenSymbol);
    }
    if (message.baseChainTokenDecimals !== 0) {
      writer.uint32(56).int32(message.baseChainTokenDecimals);
    }
    if (message.quoteChainTokenDecimals !== 0) {
      writer.uint32(64).int32(message.quoteChainTokenDecimals);
    }
    if (message.pairDecimals !== 0) {
      writer.uint32(72).int32(message.pairDecimals);
    }
    if (message.marketId !== undefined) {
      writer.uint32(82).string(message.marketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Market {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.slug = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.baseChainNetwork = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.quoteChainNetwork = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.baseChainTokenSymbol = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.quoteChainTokenSymbol = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.baseChainTokenDecimals = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.quoteChainTokenDecimals = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.pairDecimals = reader.int32();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.marketId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Market {
    return {
      slug: isSet(object.slug) ? globalThis.String(object.slug) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      baseChainNetwork: isSet(object.baseChainNetwork) ? globalThis.String(object.baseChainNetwork) : "",
      quoteChainNetwork: isSet(object.quoteChainNetwork) ? globalThis.String(object.quoteChainNetwork) : "",
      baseChainTokenSymbol: isSet(object.baseChainTokenSymbol) ? globalThis.String(object.baseChainTokenSymbol) : "",
      quoteChainTokenSymbol: isSet(object.quoteChainTokenSymbol) ? globalThis.String(object.quoteChainTokenSymbol) : "",
      baseChainTokenDecimals: isSet(object.baseChainTokenDecimals)
        ? globalThis.Number(object.baseChainTokenDecimals)
        : 0,
      quoteChainTokenDecimals: isSet(object.quoteChainTokenDecimals)
        ? globalThis.Number(object.quoteChainTokenDecimals)
        : 0,
      pairDecimals: isSet(object.pairDecimals) ? globalThis.Number(object.pairDecimals) : 0,
      marketId: isSet(object.marketId) ? globalThis.String(object.marketId) : undefined,
    };
  },

  toJSON(message: Market): unknown {
    const obj: any = {};
    if (message.slug !== "") {
      obj.slug = message.slug;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.baseChainNetwork !== "") {
      obj.baseChainNetwork = message.baseChainNetwork;
    }
    if (message.quoteChainNetwork !== "") {
      obj.quoteChainNetwork = message.quoteChainNetwork;
    }
    if (message.baseChainTokenSymbol !== "") {
      obj.baseChainTokenSymbol = message.baseChainTokenSymbol;
    }
    if (message.quoteChainTokenSymbol !== "") {
      obj.quoteChainTokenSymbol = message.quoteChainTokenSymbol;
    }
    if (message.baseChainTokenDecimals !== 0) {
      obj.baseChainTokenDecimals = Math.round(message.baseChainTokenDecimals);
    }
    if (message.quoteChainTokenDecimals !== 0) {
      obj.quoteChainTokenDecimals = Math.round(message.quoteChainTokenDecimals);
    }
    if (message.pairDecimals !== 0) {
      obj.pairDecimals = Math.round(message.pairDecimals);
    }
    if (message.marketId !== undefined) {
      obj.marketId = message.marketId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Market>, I>>(base?: I): Market {
    return Market.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Market>, I>>(object: I): Market {
    const message = createBaseMarket();
    message.slug = object.slug ?? "";
    message.name = object.name ?? "";
    message.baseChainNetwork = object.baseChainNetwork ?? "";
    message.quoteChainNetwork = object.quoteChainNetwork ?? "";
    message.baseChainTokenSymbol = object.baseChainTokenSymbol ?? "";
    message.quoteChainTokenSymbol = object.quoteChainTokenSymbol ?? "";
    message.baseChainTokenDecimals = object.baseChainTokenDecimals ?? 0;
    message.quoteChainTokenDecimals = object.quoteChainTokenDecimals ?? 0;
    message.pairDecimals = object.pairDecimals ?? 0;
    message.marketId = object.marketId ?? undefined;
    return message;
  },
};

function createBaseToken(): Token {
  return { name: "", symbol: "", address: "", tokenId: undefined, decimals: 0, tradePrecision: 0 };
}

export const Token = {
  encode(message: Token, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.symbol !== "") {
      writer.uint32(18).string(message.symbol);
    }
    if (message.address !== "") {
      writer.uint32(26).string(message.address);
    }
    if (message.tokenId !== undefined) {
      writer.uint32(34).string(message.tokenId);
    }
    if (message.decimals !== 0) {
      writer.uint32(40).int32(message.decimals);
    }
    if (message.tradePrecision !== 0) {
      writer.uint32(48).int32(message.tradePrecision);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Token {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.symbol = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.address = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.tokenId = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.decimals = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.tradePrecision = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Token {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      tokenId: isSet(object.tokenId) ? globalThis.String(object.tokenId) : undefined,
      decimals: isSet(object.decimals) ? globalThis.Number(object.decimals) : 0,
      tradePrecision: isSet(object.tradePrecision) ? globalThis.Number(object.tradePrecision) : 0,
    };
  },

  toJSON(message: Token): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.tokenId !== undefined) {
      obj.tokenId = message.tokenId;
    }
    if (message.decimals !== 0) {
      obj.decimals = Math.round(message.decimals);
    }
    if (message.tradePrecision !== 0) {
      obj.tradePrecision = Math.round(message.tradePrecision);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Token>, I>>(base?: I): Token {
    return Token.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Token>, I>>(object: I): Token {
    const message = createBaseToken();
    message.name = object.name ?? "";
    message.symbol = object.symbol ?? "";
    message.address = object.address ?? "";
    message.tokenId = object.tokenId ?? undefined;
    message.decimals = object.decimals ?? 0;
    message.tradePrecision = object.tradePrecision ?? 0;
    return message;
  },
};

function createBaseDeleteMarketRequest(): DeleteMarketRequest {
  return { marketId: "" };
}

export const DeleteMarketRequest = {
  encode(message: DeleteMarketRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteMarketRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteMarketRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.marketId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteMarketRequest {
    return { marketId: isSet(object.marketId) ? globalThis.String(object.marketId) : "" };
  },

  toJSON(message: DeleteMarketRequest): unknown {
    const obj: any = {};
    if (message.marketId !== "") {
      obj.marketId = message.marketId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteMarketRequest>, I>>(base?: I): DeleteMarketRequest {
    return DeleteMarketRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteMarketRequest>, I>>(object: I): DeleteMarketRequest {
    const message = createBaseDeleteMarketRequest();
    message.marketId = object.marketId ?? "";
    return message;
  },
};

function createBaseDeleteMarketResponse(): DeleteMarketResponse {
  return { success: false, config: undefined };
}

export const DeleteMarketResponse = {
  encode(message: DeleteMarketResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.config !== undefined) {
      Configuration.encode(message.config, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteMarketResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteMarketResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.config = Configuration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteMarketResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      config: isSet(object.config) ? Configuration.fromJSON(object.config) : undefined,
    };
  },

  toJSON(message: DeleteMarketResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.config !== undefined) {
      obj.config = Configuration.toJSON(message.config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteMarketResponse>, I>>(base?: I): DeleteMarketResponse {
    return DeleteMarketResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteMarketResponse>, I>>(object: I): DeleteMarketResponse {
    const message = createBaseDeleteMarketResponse();
    message.success = object.success ?? false;
    message.config = (object.config !== undefined && object.config !== null)
      ? Configuration.fromPartial(object.config)
      : undefined;
    return message;
  },
};

function createBaseDeleteTokenRequest(): DeleteTokenRequest {
  return { chainNetwork: "", tokenSymbol: "" };
}

export const DeleteTokenRequest = {
  encode(message: DeleteTokenRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chainNetwork !== "") {
      writer.uint32(10).string(message.chainNetwork);
    }
    if (message.tokenSymbol !== "") {
      writer.uint32(18).string(message.tokenSymbol);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteTokenRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chainNetwork = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tokenSymbol = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteTokenRequest {
    return {
      chainNetwork: isSet(object.chainNetwork) ? globalThis.String(object.chainNetwork) : "",
      tokenSymbol: isSet(object.tokenSymbol) ? globalThis.String(object.tokenSymbol) : "",
    };
  },

  toJSON(message: DeleteTokenRequest): unknown {
    const obj: any = {};
    if (message.chainNetwork !== "") {
      obj.chainNetwork = message.chainNetwork;
    }
    if (message.tokenSymbol !== "") {
      obj.tokenSymbol = message.tokenSymbol;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteTokenRequest>, I>>(base?: I): DeleteTokenRequest {
    return DeleteTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteTokenRequest>, I>>(object: I): DeleteTokenRequest {
    const message = createBaseDeleteTokenRequest();
    message.chainNetwork = object.chainNetwork ?? "";
    message.tokenSymbol = object.tokenSymbol ?? "";
    return message;
  },
};

function createBaseDeleteTokenResponse(): DeleteTokenResponse {
  return { success: false, config: undefined };
}

export const DeleteTokenResponse = {
  encode(message: DeleteTokenResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.config !== undefined) {
      Configuration.encode(message.config, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteTokenResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.config = Configuration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteTokenResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      config: isSet(object.config) ? Configuration.fromJSON(object.config) : undefined,
    };
  },

  toJSON(message: DeleteTokenResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.config !== undefined) {
      obj.config = Configuration.toJSON(message.config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteTokenResponse>, I>>(base?: I): DeleteTokenResponse {
    return DeleteTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteTokenResponse>, I>>(object: I): DeleteTokenResponse {
    const message = createBaseDeleteTokenResponse();
    message.success = object.success ?? false;
    message.config = (object.config !== undefined && object.config !== null)
      ? Configuration.fromPartial(object.config)
      : undefined;
    return message;
  },
};

function createBaseDeleteChainRequest(): DeleteChainRequest {
  return { chainNetwork: "" };
}

export const DeleteChainRequest = {
  encode(message: DeleteChainRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chainNetwork !== "") {
      writer.uint32(10).string(message.chainNetwork);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteChainRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteChainRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chainNetwork = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteChainRequest {
    return { chainNetwork: isSet(object.chainNetwork) ? globalThis.String(object.chainNetwork) : "" };
  },

  toJSON(message: DeleteChainRequest): unknown {
    const obj: any = {};
    if (message.chainNetwork !== "") {
      obj.chainNetwork = message.chainNetwork;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteChainRequest>, I>>(base?: I): DeleteChainRequest {
    return DeleteChainRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteChainRequest>, I>>(object: I): DeleteChainRequest {
    const message = createBaseDeleteChainRequest();
    message.chainNetwork = object.chainNetwork ?? "";
    return message;
  },
};

function createBaseDeleteChainResponse(): DeleteChainResponse {
  return { success: false, config: undefined };
}

export const DeleteChainResponse = {
  encode(message: DeleteChainResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.config !== undefined) {
      Configuration.encode(message.config, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteChainResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteChainResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.config = Configuration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteChainResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      config: isSet(object.config) ? Configuration.fromJSON(object.config) : undefined,
    };
  },

  toJSON(message: DeleteChainResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.config !== undefined) {
      obj.config = Configuration.toJSON(message.config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteChainResponse>, I>>(base?: I): DeleteChainResponse {
    return DeleteChainResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteChainResponse>, I>>(object: I): DeleteChainResponse {
    const message = createBaseDeleteChainResponse();
    message.success = object.success ?? false;
    message.config = (object.config !== undefined && object.config !== null)
      ? Configuration.fromPartial(object.config)
      : undefined;
    return message;
  },
};

function createBaseDeleteTradeContractRequest(): DeleteTradeContractRequest {
  return { chainId: 0 };
}

export const DeleteTradeContractRequest = {
  encode(message: DeleteTradeContractRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chainId !== 0) {
      writer.uint32(8).int32(message.chainId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteTradeContractRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTradeContractRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.chainId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteTradeContractRequest {
    return { chainId: isSet(object.chainId) ? globalThis.Number(object.chainId) : 0 };
  },

  toJSON(message: DeleteTradeContractRequest): unknown {
    const obj: any = {};
    if (message.chainId !== 0) {
      obj.chainId = Math.round(message.chainId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteTradeContractRequest>, I>>(base?: I): DeleteTradeContractRequest {
    return DeleteTradeContractRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteTradeContractRequest>, I>>(object: I): DeleteTradeContractRequest {
    const message = createBaseDeleteTradeContractRequest();
    message.chainId = object.chainId ?? 0;
    return message;
  },
};

function createBaseDeleteTradeContractResponse(): DeleteTradeContractResponse {
  return { success: false, config: undefined };
}

export const DeleteTradeContractResponse = {
  encode(message: DeleteTradeContractResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.config !== undefined) {
      Configuration.encode(message.config, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteTradeContractResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTradeContractResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.config = Configuration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteTradeContractResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      config: isSet(object.config) ? Configuration.fromJSON(object.config) : undefined,
    };
  },

  toJSON(message: DeleteTradeContractResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.config !== undefined) {
      obj.config = Configuration.toJSON(message.config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteTradeContractResponse>, I>>(base?: I): DeleteTradeContractResponse {
    return DeleteTradeContractResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteTradeContractResponse>, I>>(object: I): DeleteTradeContractResponse {
    const message = createBaseDeleteTradeContractResponse();
    message.success = object.success ?? false;
    message.config = (object.config !== undefined && object.config !== null)
      ? Configuration.fromPartial(object.config)
      : undefined;
    return message;
  },
};

function createBaseEmpty(): Empty {
  return {};
}

export const Empty = {
  encode(_: Empty, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Empty {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Empty {
    return {};
  },

  toJSON(_: Empty): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Empty>, I>>(base?: I): Empty {
    return Empty.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Empty>, I>>(_: I): Empty {
    const message = createBaseEmpty();
    return message;
  },
};

function createBaseVersionInfo(): VersionInfo {
  return {
    version: "",
    gitCommitHash: "",
    gitCommitDate: "",
    gitBranch: "",
    buildTimestamp: "",
    targetTriple: "",
    rustcVersion: "",
    cargoFeatures: [],
  };
}

export const VersionInfo = {
  encode(message: VersionInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    if (message.gitCommitHash !== "") {
      writer.uint32(18).string(message.gitCommitHash);
    }
    if (message.gitCommitDate !== "") {
      writer.uint32(26).string(message.gitCommitDate);
    }
    if (message.gitBranch !== "") {
      writer.uint32(34).string(message.gitBranch);
    }
    if (message.buildTimestamp !== "") {
      writer.uint32(42).string(message.buildTimestamp);
    }
    if (message.targetTriple !== "") {
      writer.uint32(50).string(message.targetTriple);
    }
    if (message.rustcVersion !== "") {
      writer.uint32(58).string(message.rustcVersion);
    }
    for (const v of message.cargoFeatures) {
      writer.uint32(66).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VersionInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVersionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gitCommitHash = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.gitCommitDate = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.gitBranch = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.buildTimestamp = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.targetTriple = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.rustcVersion = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.cargoFeatures.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VersionInfo {
    return {
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      gitCommitHash: isSet(object.gitCommitHash) ? globalThis.String(object.gitCommitHash) : "",
      gitCommitDate: isSet(object.gitCommitDate) ? globalThis.String(object.gitCommitDate) : "",
      gitBranch: isSet(object.gitBranch) ? globalThis.String(object.gitBranch) : "",
      buildTimestamp: isSet(object.buildTimestamp) ? globalThis.String(object.buildTimestamp) : "",
      targetTriple: isSet(object.targetTriple) ? globalThis.String(object.targetTriple) : "",
      rustcVersion: isSet(object.rustcVersion) ? globalThis.String(object.rustcVersion) : "",
      cargoFeatures: globalThis.Array.isArray(object?.cargoFeatures)
        ? object.cargoFeatures.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: VersionInfo): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.gitCommitHash !== "") {
      obj.gitCommitHash = message.gitCommitHash;
    }
    if (message.gitCommitDate !== "") {
      obj.gitCommitDate = message.gitCommitDate;
    }
    if (message.gitBranch !== "") {
      obj.gitBranch = message.gitBranch;
    }
    if (message.buildTimestamp !== "") {
      obj.buildTimestamp = message.buildTimestamp;
    }
    if (message.targetTriple !== "") {
      obj.targetTriple = message.targetTriple;
    }
    if (message.rustcVersion !== "") {
      obj.rustcVersion = message.rustcVersion;
    }
    if (message.cargoFeatures?.length) {
      obj.cargoFeatures = message.cargoFeatures;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VersionInfo>, I>>(base?: I): VersionInfo {
    return VersionInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VersionInfo>, I>>(object: I): VersionInfo {
    const message = createBaseVersionInfo();
    message.version = object.version ?? "";
    message.gitCommitHash = object.gitCommitHash ?? "";
    message.gitCommitDate = object.gitCommitDate ?? "";
    message.gitBranch = object.gitBranch ?? "";
    message.buildTimestamp = object.buildTimestamp ?? "";
    message.targetTriple = object.targetTriple ?? "";
    message.rustcVersion = object.rustcVersion ?? "";
    message.cargoFeatures = object.cargoFeatures?.map((e) => e) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
