// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: src/proto/arborter.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";

export const protobufPackage = "xyz.aspens.arborter.v1";

export enum Side {
  SIDE_UNSPECIFIED = 0,
  SIDE_BID = 1,
  SIDE_ASK = 2,
  UNRECOGNIZED = -1,
}

export function sideFromJSON(object: any): Side {
  switch (object) {
    case 0:
    case "SIDE_UNSPECIFIED":
      return Side.SIDE_UNSPECIFIED;
    case 1:
    case "SIDE_BID":
      return Side.SIDE_BID;
    case 2:
    case "SIDE_ASK":
      return Side.SIDE_ASK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Side.UNRECOGNIZED;
  }
}

export function sideToJSON(object: Side): string {
  switch (object) {
    case Side.SIDE_UNSPECIFIED:
      return "SIDE_UNSPECIFIED";
    case Side.SIDE_BID:
      return "SIDE_BID";
    case Side.SIDE_ASK:
      return "SIDE_ASK";
    case Side.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ExecutionType {
  /** EXECUTION_TYPE_UNSPECIFIED - Default - direct */
  EXECUTION_TYPE_UNSPECIFIED = 0,
  /** EXECUTION_TYPE_DISCRETIONARY - For dealroom use. */
  EXECUTION_TYPE_DISCRETIONARY = 1,
  UNRECOGNIZED = -1,
}

export function executionTypeFromJSON(object: any): ExecutionType {
  switch (object) {
    case 0:
    case "EXECUTION_TYPE_UNSPECIFIED":
      return ExecutionType.EXECUTION_TYPE_UNSPECIFIED;
    case 1:
    case "EXECUTION_TYPE_DISCRETIONARY":
      return ExecutionType.EXECUTION_TYPE_DISCRETIONARY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExecutionType.UNRECOGNIZED;
  }
}

export function executionTypeToJSON(object: ExecutionType): string {
  switch (object) {
    case ExecutionType.EXECUTION_TYPE_UNSPECIFIED:
      return "EXECUTION_TYPE_UNSPECIFIED";
    case ExecutionType.EXECUTION_TYPE_DISCRETIONARY:
      return "EXECUTION_TYPE_DISCRETIONARY";
    case ExecutionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum OrderStatus {
  ORDER_STATUS_UNSPECIFIED = 0,
  /** ORDER_STATUS_ADDED - When new order is added to the book */
  ORDER_STATUS_ADDED = 1,
  /** ORDER_STATUS_UPDATED - When an existing order is updated */
  ORDER_STATUS_UPDATED = 2,
  /** ORDER_STATUS_REMOVED - When an existing order is filled completely or canceled */
  ORDER_STATUS_REMOVED = 3,
  UNRECOGNIZED = -1,
}

export function orderStatusFromJSON(object: any): OrderStatus {
  switch (object) {
    case 0:
    case "ORDER_STATUS_UNSPECIFIED":
      return OrderStatus.ORDER_STATUS_UNSPECIFIED;
    case 1:
    case "ORDER_STATUS_ADDED":
      return OrderStatus.ORDER_STATUS_ADDED;
    case 2:
    case "ORDER_STATUS_UPDATED":
      return OrderStatus.ORDER_STATUS_UPDATED;
    case 3:
    case "ORDER_STATUS_REMOVED":
      return OrderStatus.ORDER_STATUS_REMOVED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OrderStatus.UNRECOGNIZED;
  }
}

export function orderStatusToJSON(object: OrderStatus): string {
  switch (object) {
    case OrderStatus.ORDER_STATUS_UNSPECIFIED:
      return "ORDER_STATUS_UNSPECIFIED";
    case OrderStatus.ORDER_STATUS_ADDED:
      return "ORDER_STATUS_ADDED";
    case OrderStatus.ORDER_STATUS_UPDATED:
      return "ORDER_STATUS_UPDATED";
    case OrderStatus.ORDER_STATUS_REMOVED:
      return "ORDER_STATUS_REMOVED";
    case OrderStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Empty {
}

export interface CancelOrderRequest {
  order: OrderToCancel | undefined;
  signatureHash: Uint8Array;
}

export interface CancelOrderResponse {
  /** Whether the order was found and canceled */
  orderCanceled: boolean;
  /** Transaction hashes associated with this cancellation */
  transactionHashes: TransactionHash[];
}

export interface OrderbookRequest {
  /** Used to keep the client alive */
  continueStream: boolean;
  /** The market id to stream orders for */
  marketId: string;
  /** If true, returns existing open orders when stream starts, then continues streaming */
  historicalOpenOrders?:
    | boolean
    | undefined;
  /** If this is sent too, then we filter by a specific trader */
  filterByTrader?: string | undefined;
}

export interface TradeRequest {
  /** Used to keep the client alive */
  continueStream: boolean;
  /** The market id to stream orders for */
  marketId: string;
  /** If true, returns existing closed when stream starts, then continues streaming */
  historicalClosedTrades?:
    | boolean
    | undefined;
  /** If this is sent too, then we filter by a specific trader */
  filterByTrader?: string | undefined;
}

export interface SendOrderRequest {
  /** The order to send */
  order:
    | Order
    | undefined;
  /** Valid EIP-712 signature hash of this order */
  signatureHash: Uint8Array;
}

export interface Order {
  /** 'BID' or 'ASK' */
  side: Side;
  /** Order size */
  quantity: string;
  /** Optional. including is a LIMIT order. excluding is a MARKET order. */
  price?:
    | string
    | undefined;
  /** Identity the market: concat(base_chain_id "::" token_address "::" quote_chain_id "::" token_address) */
  marketId: string;
  /** User's pubkey (address)on the Base chain */
  baseAccountAddress: string;
  /** User's pubkey (address)on the Quote chain */
  quoteAccountAddress: string;
  /** 'DIRECT' (default) or 'DISCRETIONARY' */
  executionType: ExecutionType;
  /** When execution_type == 'discretionary', include order_ids to match with. */
  matchingOrderIds: number[];
}

export interface Trade {
  /** When the engine registers this executed trade */
  timestamp: number;
  /** The setttled price net of fees */
  price: string;
  /** How much or many of the quote token */
  qty: string;
  /** Maker's internal trader id. Safely ignore. */
  maker: string;
  /** Taker's internal trader id. Safely ignore. */
  taker: string;
  /** The maker's base chain wallet address */
  makerBaseAddress: string;
  /** The maker's quote chain wallet address */
  makerQuoteAddress: string;
  /** Buyer's internal trader id. Safely ignore. */
  buyer: string;
  /** Seller's internal trader id. Safely ignore. */
  seller: string;
  /** The order_id that created this trade. */
  orderHit: number;
}

/** Transaction hash information */
export interface TransactionHash {
  /** Type of transaction hash */
  hashType: string;
  /** The transaction hash value */
  hashValue: string;
}

/** rpc: SendOrder */
export interface SendOrderResponse {
  /** Whether the order has unmatched volume and has been added to the book. */
  orderInBook: boolean;
  /** If the order lands in the book, what remains unfilled from the order. */
  order?:
    | Order
    | undefined;
  /** Which other orders, if any, this order was matched with. */
  trades: Trade[];
  /** Transaction hashes associated with this order */
  transactionHashes: TransactionHash[];
}

/** rpc: CancelOrder */
export interface OrderToCancel {
  /** Identity the market: concat(base_chain_id "::" token_address "::" quote_chain_id "::" token_address) */
  marketId: string;
  /** 'BID' or 'ASK' */
  side: Side;
  /** the token address */
  tokenAddress: string;
  /** Internal order Id. */
  orderId: number;
}

/** rpc: Orderbook */
export interface OrderbookEntry {
  /** when the order first landed in The Orderbook */
  timestamp: number;
  /** internal id of the order */
  orderId: number;
  /** price of the order - in non-decimal form */
  price: string;
  /** quantity of the order - in non-decimal form */
  quantity: string;
  /** 'BID = 1' or 'ASK = 2' */
  side: Side;
  /** The maker's base chain wallet address */
  makerBaseAddress: string;
  /** The maker's quote chain wallet address */
  makerQuoteAddress: string;
  /** 'ADDED = 1', 'UPDATED = 2', 'REMOVED = 3' */
  status: OrderStatus;
  /** The market ID this order belongs to */
  marketId: string;
}

/** Request to add a new orderbook */
export interface AddOrderbookRequest {
  /** The market ID to add the orderbook for */
  marketId: string;
  /** The number of decimal places for the orderbook */
  decimalPlaces: number;
}

/** Response for adding a new orderbook */
export interface AddOrderbookResponse {
  /** Whether the orderbook was added successfully */
  success: boolean;
  /** The market ID of the created orderbook */
  marketId: string;
}

/** Request to remove an orderbook */
export interface RemoveOrderbookRequest {
  /** The market ID to remove the orderbook for */
  marketId: string;
}

/** Response for removing an orderbook */
export interface RemoveOrderbookResponse {
  /** Whether the orderbook was removed successfully */
  success: boolean;
  /** The market ID of the removed orderbook */
  marketId: string;
}

/** Converts a value in pair decimals to the correct token decimals for a given market and side */
export interface UnNormalizeDecimalsRequest {
  marketId: string;
  /** "buy" or "sell" */
  side: string;
  /** in pair decimals */
  quantity: string;
  /** in pair decimals */
  price: string;
}

export interface UnNormalizeDecimalsResponse {
  /** in base token decimals */
  baseTokenQuantity: string;
  /** in quote token decimals */
  quoteTokenQuantity: string;
  baseTokenDecimals: number;
  quoteTokenDecimals: number;
  pairDecimals: number;
}

function createBaseEmpty(): Empty {
  return {};
}

export const Empty = {
  encode(_: Empty, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Empty {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Empty {
    return {};
  },

  toJSON(_: Empty): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Empty>, I>>(base?: I): Empty {
    return Empty.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Empty>, I>>(_: I): Empty {
    const message = createBaseEmpty();
    return message;
  },
};

function createBaseCancelOrderRequest(): CancelOrderRequest {
  return { order: undefined, signatureHash: new Uint8Array(0) };
}

export const CancelOrderRequest = {
  encode(message: CancelOrderRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.order !== undefined) {
      OrderToCancel.encode(message.order, writer.uint32(10).fork()).ldelim();
    }
    if (message.signatureHash.length !== 0) {
      writer.uint32(18).bytes(message.signatureHash);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CancelOrderRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.order = OrderToCancel.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.signatureHash = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelOrderRequest {
    return {
      order: isSet(object.order) ? OrderToCancel.fromJSON(object.order) : undefined,
      signatureHash: isSet(object.signatureHash) ? bytesFromBase64(object.signatureHash) : new Uint8Array(0),
    };
  },

  toJSON(message: CancelOrderRequest): unknown {
    const obj: any = {};
    if (message.order !== undefined) {
      obj.order = OrderToCancel.toJSON(message.order);
    }
    if (message.signatureHash.length !== 0) {
      obj.signatureHash = base64FromBytes(message.signatureHash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelOrderRequest>, I>>(base?: I): CancelOrderRequest {
    return CancelOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelOrderRequest>, I>>(object: I): CancelOrderRequest {
    const message = createBaseCancelOrderRequest();
    message.order = (object.order !== undefined && object.order !== null)
      ? OrderToCancel.fromPartial(object.order)
      : undefined;
    message.signatureHash = object.signatureHash ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCancelOrderResponse(): CancelOrderResponse {
  return { orderCanceled: false, transactionHashes: [] };
}

export const CancelOrderResponse = {
  encode(message: CancelOrderResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderCanceled !== false) {
      writer.uint32(8).bool(message.orderCanceled);
    }
    for (const v of message.transactionHashes) {
      TransactionHash.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CancelOrderResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.orderCanceled = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionHashes.push(TransactionHash.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelOrderResponse {
    return {
      orderCanceled: isSet(object.orderCanceled) ? globalThis.Boolean(object.orderCanceled) : false,
      transactionHashes: globalThis.Array.isArray(object?.transactionHashes)
        ? object.transactionHashes.map((e: any) => TransactionHash.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CancelOrderResponse): unknown {
    const obj: any = {};
    if (message.orderCanceled !== false) {
      obj.orderCanceled = message.orderCanceled;
    }
    if (message.transactionHashes?.length) {
      obj.transactionHashes = message.transactionHashes.map((e) => TransactionHash.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelOrderResponse>, I>>(base?: I): CancelOrderResponse {
    return CancelOrderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelOrderResponse>, I>>(object: I): CancelOrderResponse {
    const message = createBaseCancelOrderResponse();
    message.orderCanceled = object.orderCanceled ?? false;
    message.transactionHashes = object.transactionHashes?.map((e) => TransactionHash.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOrderbookRequest(): OrderbookRequest {
  return { continueStream: false, marketId: "", historicalOpenOrders: undefined, filterByTrader: undefined };
}

export const OrderbookRequest = {
  encode(message: OrderbookRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.continueStream !== false) {
      writer.uint32(8).bool(message.continueStream);
    }
    if (message.marketId !== "") {
      writer.uint32(18).string(message.marketId);
    }
    if (message.historicalOpenOrders !== undefined) {
      writer.uint32(24).bool(message.historicalOpenOrders);
    }
    if (message.filterByTrader !== undefined) {
      writer.uint32(34).string(message.filterByTrader);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrderbookRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderbookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.continueStream = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.marketId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.historicalOpenOrders = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filterByTrader = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderbookRequest {
    return {
      continueStream: isSet(object.continueStream) ? globalThis.Boolean(object.continueStream) : false,
      marketId: isSet(object.marketId) ? globalThis.String(object.marketId) : "",
      historicalOpenOrders: isSet(object.historicalOpenOrders)
        ? globalThis.Boolean(object.historicalOpenOrders)
        : undefined,
      filterByTrader: isSet(object.filterByTrader) ? globalThis.String(object.filterByTrader) : undefined,
    };
  },

  toJSON(message: OrderbookRequest): unknown {
    const obj: any = {};
    if (message.continueStream !== false) {
      obj.continueStream = message.continueStream;
    }
    if (message.marketId !== "") {
      obj.marketId = message.marketId;
    }
    if (message.historicalOpenOrders !== undefined) {
      obj.historicalOpenOrders = message.historicalOpenOrders;
    }
    if (message.filterByTrader !== undefined) {
      obj.filterByTrader = message.filterByTrader;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderbookRequest>, I>>(base?: I): OrderbookRequest {
    return OrderbookRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderbookRequest>, I>>(object: I): OrderbookRequest {
    const message = createBaseOrderbookRequest();
    message.continueStream = object.continueStream ?? false;
    message.marketId = object.marketId ?? "";
    message.historicalOpenOrders = object.historicalOpenOrders ?? undefined;
    message.filterByTrader = object.filterByTrader ?? undefined;
    return message;
  },
};

function createBaseTradeRequest(): TradeRequest {
  return { continueStream: false, marketId: "", historicalClosedTrades: undefined, filterByTrader: undefined };
}

export const TradeRequest = {
  encode(message: TradeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.continueStream !== false) {
      writer.uint32(8).bool(message.continueStream);
    }
    if (message.marketId !== "") {
      writer.uint32(18).string(message.marketId);
    }
    if (message.historicalClosedTrades !== undefined) {
      writer.uint32(24).bool(message.historicalClosedTrades);
    }
    if (message.filterByTrader !== undefined) {
      writer.uint32(34).string(message.filterByTrader);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TradeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTradeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.continueStream = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.marketId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.historicalClosedTrades = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filterByTrader = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TradeRequest {
    return {
      continueStream: isSet(object.continueStream) ? globalThis.Boolean(object.continueStream) : false,
      marketId: isSet(object.marketId) ? globalThis.String(object.marketId) : "",
      historicalClosedTrades: isSet(object.historicalClosedTrades)
        ? globalThis.Boolean(object.historicalClosedTrades)
        : undefined,
      filterByTrader: isSet(object.filterByTrader) ? globalThis.String(object.filterByTrader) : undefined,
    };
  },

  toJSON(message: TradeRequest): unknown {
    const obj: any = {};
    if (message.continueStream !== false) {
      obj.continueStream = message.continueStream;
    }
    if (message.marketId !== "") {
      obj.marketId = message.marketId;
    }
    if (message.historicalClosedTrades !== undefined) {
      obj.historicalClosedTrades = message.historicalClosedTrades;
    }
    if (message.filterByTrader !== undefined) {
      obj.filterByTrader = message.filterByTrader;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TradeRequest>, I>>(base?: I): TradeRequest {
    return TradeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TradeRequest>, I>>(object: I): TradeRequest {
    const message = createBaseTradeRequest();
    message.continueStream = object.continueStream ?? false;
    message.marketId = object.marketId ?? "";
    message.historicalClosedTrades = object.historicalClosedTrades ?? undefined;
    message.filterByTrader = object.filterByTrader ?? undefined;
    return message;
  },
};

function createBaseSendOrderRequest(): SendOrderRequest {
  return { order: undefined, signatureHash: new Uint8Array(0) };
}

export const SendOrderRequest = {
  encode(message: SendOrderRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.order !== undefined) {
      Order.encode(message.order, writer.uint32(10).fork()).ldelim();
    }
    if (message.signatureHash.length !== 0) {
      writer.uint32(18).bytes(message.signatureHash);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SendOrderRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.order = Order.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.signatureHash = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendOrderRequest {
    return {
      order: isSet(object.order) ? Order.fromJSON(object.order) : undefined,
      signatureHash: isSet(object.signatureHash) ? bytesFromBase64(object.signatureHash) : new Uint8Array(0),
    };
  },

  toJSON(message: SendOrderRequest): unknown {
    const obj: any = {};
    if (message.order !== undefined) {
      obj.order = Order.toJSON(message.order);
    }
    if (message.signatureHash.length !== 0) {
      obj.signatureHash = base64FromBytes(message.signatureHash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendOrderRequest>, I>>(base?: I): SendOrderRequest {
    return SendOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendOrderRequest>, I>>(object: I): SendOrderRequest {
    const message = createBaseSendOrderRequest();
    message.order = (object.order !== undefined && object.order !== null) ? Order.fromPartial(object.order) : undefined;
    message.signatureHash = object.signatureHash ?? new Uint8Array(0);
    return message;
  },
};

function createBaseOrder(): Order {
  return {
    side: 0,
    quantity: "",
    price: undefined,
    marketId: "",
    baseAccountAddress: "",
    quoteAccountAddress: "",
    executionType: 0,
    matchingOrderIds: [],
  };
}

export const Order = {
  encode(message: Order, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.side !== 0) {
      writer.uint32(8).int32(message.side);
    }
    if (message.quantity !== "") {
      writer.uint32(18).string(message.quantity);
    }
    if (message.price !== undefined) {
      writer.uint32(26).string(message.price);
    }
    if (message.marketId !== "") {
      writer.uint32(34).string(message.marketId);
    }
    if (message.baseAccountAddress !== "") {
      writer.uint32(42).string(message.baseAccountAddress);
    }
    if (message.quoteAccountAddress !== "") {
      writer.uint32(50).string(message.quoteAccountAddress);
    }
    if (message.executionType !== 0) {
      writer.uint32(56).int32(message.executionType);
    }
    writer.uint32(66).fork();
    for (const v of message.matchingOrderIds) {
      writer.uint64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Order {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.side = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.quantity = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.price = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.marketId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.baseAccountAddress = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.quoteAccountAddress = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.executionType = reader.int32() as any;
          continue;
        case 8:
          if (tag === 64) {
            message.matchingOrderIds.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.matchingOrderIds.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Order {
    return {
      side: isSet(object.side) ? sideFromJSON(object.side) : 0,
      quantity: isSet(object.quantity) ? globalThis.String(object.quantity) : "",
      price: isSet(object.price) ? globalThis.String(object.price) : undefined,
      marketId: isSet(object.marketId) ? globalThis.String(object.marketId) : "",
      baseAccountAddress: isSet(object.baseAccountAddress) ? globalThis.String(object.baseAccountAddress) : "",
      quoteAccountAddress: isSet(object.quoteAccountAddress) ? globalThis.String(object.quoteAccountAddress) : "",
      executionType: isSet(object.executionType) ? executionTypeFromJSON(object.executionType) : 0,
      matchingOrderIds: globalThis.Array.isArray(object?.matchingOrderIds)
        ? object.matchingOrderIds.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: Order): unknown {
    const obj: any = {};
    if (message.side !== 0) {
      obj.side = sideToJSON(message.side);
    }
    if (message.quantity !== "") {
      obj.quantity = message.quantity;
    }
    if (message.price !== undefined) {
      obj.price = message.price;
    }
    if (message.marketId !== "") {
      obj.marketId = message.marketId;
    }
    if (message.baseAccountAddress !== "") {
      obj.baseAccountAddress = message.baseAccountAddress;
    }
    if (message.quoteAccountAddress !== "") {
      obj.quoteAccountAddress = message.quoteAccountAddress;
    }
    if (message.executionType !== 0) {
      obj.executionType = executionTypeToJSON(message.executionType);
    }
    if (message.matchingOrderIds?.length) {
      obj.matchingOrderIds = message.matchingOrderIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Order>, I>>(base?: I): Order {
    return Order.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Order>, I>>(object: I): Order {
    const message = createBaseOrder();
    message.side = object.side ?? 0;
    message.quantity = object.quantity ?? "";
    message.price = object.price ?? undefined;
    message.marketId = object.marketId ?? "";
    message.baseAccountAddress = object.baseAccountAddress ?? "";
    message.quoteAccountAddress = object.quoteAccountAddress ?? "";
    message.executionType = object.executionType ?? 0;
    message.matchingOrderIds = object.matchingOrderIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseTrade(): Trade {
  return {
    timestamp: 0,
    price: "",
    qty: "",
    maker: "",
    taker: "",
    makerBaseAddress: "",
    makerQuoteAddress: "",
    buyer: "",
    seller: "",
    orderHit: 0,
  };
}

export const Trade = {
  encode(message: Trade, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.timestamp !== 0) {
      writer.uint32(8).uint64(message.timestamp);
    }
    if (message.price !== "") {
      writer.uint32(18).string(message.price);
    }
    if (message.qty !== "") {
      writer.uint32(26).string(message.qty);
    }
    if (message.maker !== "") {
      writer.uint32(34).string(message.maker);
    }
    if (message.taker !== "") {
      writer.uint32(42).string(message.taker);
    }
    if (message.makerBaseAddress !== "") {
      writer.uint32(50).string(message.makerBaseAddress);
    }
    if (message.makerQuoteAddress !== "") {
      writer.uint32(58).string(message.makerQuoteAddress);
    }
    if (message.buyer !== "") {
      writer.uint32(66).string(message.buyer);
    }
    if (message.seller !== "") {
      writer.uint32(74).string(message.seller);
    }
    if (message.orderHit !== 0) {
      writer.uint32(80).uint64(message.orderHit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Trade {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrade();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.timestamp = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.price = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.qty = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.maker = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.taker = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.makerBaseAddress = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.makerQuoteAddress = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.buyer = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.seller = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.orderHit = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Trade {
    return {
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      price: isSet(object.price) ? globalThis.String(object.price) : "",
      qty: isSet(object.qty) ? globalThis.String(object.qty) : "",
      maker: isSet(object.maker) ? globalThis.String(object.maker) : "",
      taker: isSet(object.taker) ? globalThis.String(object.taker) : "",
      makerBaseAddress: isSet(object.makerBaseAddress) ? globalThis.String(object.makerBaseAddress) : "",
      makerQuoteAddress: isSet(object.makerQuoteAddress) ? globalThis.String(object.makerQuoteAddress) : "",
      buyer: isSet(object.buyer) ? globalThis.String(object.buyer) : "",
      seller: isSet(object.seller) ? globalThis.String(object.seller) : "",
      orderHit: isSet(object.orderHit) ? globalThis.Number(object.orderHit) : 0,
    };
  },

  toJSON(message: Trade): unknown {
    const obj: any = {};
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.price !== "") {
      obj.price = message.price;
    }
    if (message.qty !== "") {
      obj.qty = message.qty;
    }
    if (message.maker !== "") {
      obj.maker = message.maker;
    }
    if (message.taker !== "") {
      obj.taker = message.taker;
    }
    if (message.makerBaseAddress !== "") {
      obj.makerBaseAddress = message.makerBaseAddress;
    }
    if (message.makerQuoteAddress !== "") {
      obj.makerQuoteAddress = message.makerQuoteAddress;
    }
    if (message.buyer !== "") {
      obj.buyer = message.buyer;
    }
    if (message.seller !== "") {
      obj.seller = message.seller;
    }
    if (message.orderHit !== 0) {
      obj.orderHit = Math.round(message.orderHit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Trade>, I>>(base?: I): Trade {
    return Trade.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Trade>, I>>(object: I): Trade {
    const message = createBaseTrade();
    message.timestamp = object.timestamp ?? 0;
    message.price = object.price ?? "";
    message.qty = object.qty ?? "";
    message.maker = object.maker ?? "";
    message.taker = object.taker ?? "";
    message.makerBaseAddress = object.makerBaseAddress ?? "";
    message.makerQuoteAddress = object.makerQuoteAddress ?? "";
    message.buyer = object.buyer ?? "";
    message.seller = object.seller ?? "";
    message.orderHit = object.orderHit ?? 0;
    return message;
  },
};

function createBaseTransactionHash(): TransactionHash {
  return { hashType: "", hashValue: "" };
}

export const TransactionHash = {
  encode(message: TransactionHash, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.hashType !== "") {
      writer.uint32(10).string(message.hashType);
    }
    if (message.hashValue !== "") {
      writer.uint32(18).string(message.hashValue);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionHash {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionHash();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hashType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hashValue = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionHash {
    return {
      hashType: isSet(object.hashType) ? globalThis.String(object.hashType) : "",
      hashValue: isSet(object.hashValue) ? globalThis.String(object.hashValue) : "",
    };
  },

  toJSON(message: TransactionHash): unknown {
    const obj: any = {};
    if (message.hashType !== "") {
      obj.hashType = message.hashType;
    }
    if (message.hashValue !== "") {
      obj.hashValue = message.hashValue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionHash>, I>>(base?: I): TransactionHash {
    return TransactionHash.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionHash>, I>>(object: I): TransactionHash {
    const message = createBaseTransactionHash();
    message.hashType = object.hashType ?? "";
    message.hashValue = object.hashValue ?? "";
    return message;
  },
};

function createBaseSendOrderResponse(): SendOrderResponse {
  return { orderInBook: false, order: undefined, trades: [], transactionHashes: [] };
}

export const SendOrderResponse = {
  encode(message: SendOrderResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderInBook !== false) {
      writer.uint32(8).bool(message.orderInBook);
    }
    if (message.order !== undefined) {
      Order.encode(message.order, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.trades) {
      Trade.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.transactionHashes) {
      TransactionHash.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SendOrderResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.orderInBook = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.order = Order.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.trades.push(Trade.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.transactionHashes.push(TransactionHash.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendOrderResponse {
    return {
      orderInBook: isSet(object.orderInBook) ? globalThis.Boolean(object.orderInBook) : false,
      order: isSet(object.order) ? Order.fromJSON(object.order) : undefined,
      trades: globalThis.Array.isArray(object?.trades) ? object.trades.map((e: any) => Trade.fromJSON(e)) : [],
      transactionHashes: globalThis.Array.isArray(object?.transactionHashes)
        ? object.transactionHashes.map((e: any) => TransactionHash.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SendOrderResponse): unknown {
    const obj: any = {};
    if (message.orderInBook !== false) {
      obj.orderInBook = message.orderInBook;
    }
    if (message.order !== undefined) {
      obj.order = Order.toJSON(message.order);
    }
    if (message.trades?.length) {
      obj.trades = message.trades.map((e) => Trade.toJSON(e));
    }
    if (message.transactionHashes?.length) {
      obj.transactionHashes = message.transactionHashes.map((e) => TransactionHash.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendOrderResponse>, I>>(base?: I): SendOrderResponse {
    return SendOrderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendOrderResponse>, I>>(object: I): SendOrderResponse {
    const message = createBaseSendOrderResponse();
    message.orderInBook = object.orderInBook ?? false;
    message.order = (object.order !== undefined && object.order !== null) ? Order.fromPartial(object.order) : undefined;
    message.trades = object.trades?.map((e) => Trade.fromPartial(e)) || [];
    message.transactionHashes = object.transactionHashes?.map((e) => TransactionHash.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOrderToCancel(): OrderToCancel {
  return { marketId: "", side: 0, tokenAddress: "", orderId: 0 };
}

export const OrderToCancel = {
  encode(message: OrderToCancel, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.side !== 0) {
      writer.uint32(16).int32(message.side);
    }
    if (message.tokenAddress !== "") {
      writer.uint32(26).string(message.tokenAddress);
    }
    if (message.orderId !== 0) {
      writer.uint32(32).uint64(message.orderId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrderToCancel {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderToCancel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.marketId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.side = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tokenAddress = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.orderId = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderToCancel {
    return {
      marketId: isSet(object.marketId) ? globalThis.String(object.marketId) : "",
      side: isSet(object.side) ? sideFromJSON(object.side) : 0,
      tokenAddress: isSet(object.tokenAddress) ? globalThis.String(object.tokenAddress) : "",
      orderId: isSet(object.orderId) ? globalThis.Number(object.orderId) : 0,
    };
  },

  toJSON(message: OrderToCancel): unknown {
    const obj: any = {};
    if (message.marketId !== "") {
      obj.marketId = message.marketId;
    }
    if (message.side !== 0) {
      obj.side = sideToJSON(message.side);
    }
    if (message.tokenAddress !== "") {
      obj.tokenAddress = message.tokenAddress;
    }
    if (message.orderId !== 0) {
      obj.orderId = Math.round(message.orderId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderToCancel>, I>>(base?: I): OrderToCancel {
    return OrderToCancel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderToCancel>, I>>(object: I): OrderToCancel {
    const message = createBaseOrderToCancel();
    message.marketId = object.marketId ?? "";
    message.side = object.side ?? 0;
    message.tokenAddress = object.tokenAddress ?? "";
    message.orderId = object.orderId ?? 0;
    return message;
  },
};

function createBaseOrderbookEntry(): OrderbookEntry {
  return {
    timestamp: 0,
    orderId: 0,
    price: "",
    quantity: "",
    side: 0,
    makerBaseAddress: "",
    makerQuoteAddress: "",
    status: 0,
    marketId: "",
  };
}

export const OrderbookEntry = {
  encode(message: OrderbookEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.timestamp !== 0) {
      writer.uint32(8).uint64(message.timestamp);
    }
    if (message.orderId !== 0) {
      writer.uint32(16).uint64(message.orderId);
    }
    if (message.price !== "") {
      writer.uint32(26).string(message.price);
    }
    if (message.quantity !== "") {
      writer.uint32(34).string(message.quantity);
    }
    if (message.side !== 0) {
      writer.uint32(40).int32(message.side);
    }
    if (message.makerBaseAddress !== "") {
      writer.uint32(50).string(message.makerBaseAddress);
    }
    if (message.makerQuoteAddress !== "") {
      writer.uint32(58).string(message.makerQuoteAddress);
    }
    if (message.status !== 0) {
      writer.uint32(64).int32(message.status);
    }
    if (message.marketId !== "") {
      writer.uint32(74).string(message.marketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrderbookEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderbookEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.timestamp = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.orderId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.price = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.quantity = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.side = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.makerBaseAddress = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.makerQuoteAddress = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.marketId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderbookEntry {
    return {
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      orderId: isSet(object.orderId) ? globalThis.Number(object.orderId) : 0,
      price: isSet(object.price) ? globalThis.String(object.price) : "",
      quantity: isSet(object.quantity) ? globalThis.String(object.quantity) : "",
      side: isSet(object.side) ? sideFromJSON(object.side) : 0,
      makerBaseAddress: isSet(object.makerBaseAddress) ? globalThis.String(object.makerBaseAddress) : "",
      makerQuoteAddress: isSet(object.makerQuoteAddress) ? globalThis.String(object.makerQuoteAddress) : "",
      status: isSet(object.status) ? orderStatusFromJSON(object.status) : 0,
      marketId: isSet(object.marketId) ? globalThis.String(object.marketId) : "",
    };
  },

  toJSON(message: OrderbookEntry): unknown {
    const obj: any = {};
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.orderId !== 0) {
      obj.orderId = Math.round(message.orderId);
    }
    if (message.price !== "") {
      obj.price = message.price;
    }
    if (message.quantity !== "") {
      obj.quantity = message.quantity;
    }
    if (message.side !== 0) {
      obj.side = sideToJSON(message.side);
    }
    if (message.makerBaseAddress !== "") {
      obj.makerBaseAddress = message.makerBaseAddress;
    }
    if (message.makerQuoteAddress !== "") {
      obj.makerQuoteAddress = message.makerQuoteAddress;
    }
    if (message.status !== 0) {
      obj.status = orderStatusToJSON(message.status);
    }
    if (message.marketId !== "") {
      obj.marketId = message.marketId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderbookEntry>, I>>(base?: I): OrderbookEntry {
    return OrderbookEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderbookEntry>, I>>(object: I): OrderbookEntry {
    const message = createBaseOrderbookEntry();
    message.timestamp = object.timestamp ?? 0;
    message.orderId = object.orderId ?? 0;
    message.price = object.price ?? "";
    message.quantity = object.quantity ?? "";
    message.side = object.side ?? 0;
    message.makerBaseAddress = object.makerBaseAddress ?? "";
    message.makerQuoteAddress = object.makerQuoteAddress ?? "";
    message.status = object.status ?? 0;
    message.marketId = object.marketId ?? "";
    return message;
  },
};

function createBaseAddOrderbookRequest(): AddOrderbookRequest {
  return { marketId: "", decimalPlaces: 0 };
}

export const AddOrderbookRequest = {
  encode(message: AddOrderbookRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.decimalPlaces !== 0) {
      writer.uint32(16).int32(message.decimalPlaces);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddOrderbookRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddOrderbookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.marketId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.decimalPlaces = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddOrderbookRequest {
    return {
      marketId: isSet(object.marketId) ? globalThis.String(object.marketId) : "",
      decimalPlaces: isSet(object.decimalPlaces) ? globalThis.Number(object.decimalPlaces) : 0,
    };
  },

  toJSON(message: AddOrderbookRequest): unknown {
    const obj: any = {};
    if (message.marketId !== "") {
      obj.marketId = message.marketId;
    }
    if (message.decimalPlaces !== 0) {
      obj.decimalPlaces = Math.round(message.decimalPlaces);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddOrderbookRequest>, I>>(base?: I): AddOrderbookRequest {
    return AddOrderbookRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddOrderbookRequest>, I>>(object: I): AddOrderbookRequest {
    const message = createBaseAddOrderbookRequest();
    message.marketId = object.marketId ?? "";
    message.decimalPlaces = object.decimalPlaces ?? 0;
    return message;
  },
};

function createBaseAddOrderbookResponse(): AddOrderbookResponse {
  return { success: false, marketId: "" };
}

export const AddOrderbookResponse = {
  encode(message: AddOrderbookResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.marketId !== "") {
      writer.uint32(18).string(message.marketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddOrderbookResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddOrderbookResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.marketId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddOrderbookResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      marketId: isSet(object.marketId) ? globalThis.String(object.marketId) : "",
    };
  },

  toJSON(message: AddOrderbookResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.marketId !== "") {
      obj.marketId = message.marketId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddOrderbookResponse>, I>>(base?: I): AddOrderbookResponse {
    return AddOrderbookResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddOrderbookResponse>, I>>(object: I): AddOrderbookResponse {
    const message = createBaseAddOrderbookResponse();
    message.success = object.success ?? false;
    message.marketId = object.marketId ?? "";
    return message;
  },
};

function createBaseRemoveOrderbookRequest(): RemoveOrderbookRequest {
  return { marketId: "" };
}

export const RemoveOrderbookRequest = {
  encode(message: RemoveOrderbookRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RemoveOrderbookRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveOrderbookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.marketId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveOrderbookRequest {
    return { marketId: isSet(object.marketId) ? globalThis.String(object.marketId) : "" };
  },

  toJSON(message: RemoveOrderbookRequest): unknown {
    const obj: any = {};
    if (message.marketId !== "") {
      obj.marketId = message.marketId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveOrderbookRequest>, I>>(base?: I): RemoveOrderbookRequest {
    return RemoveOrderbookRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveOrderbookRequest>, I>>(object: I): RemoveOrderbookRequest {
    const message = createBaseRemoveOrderbookRequest();
    message.marketId = object.marketId ?? "";
    return message;
  },
};

function createBaseRemoveOrderbookResponse(): RemoveOrderbookResponse {
  return { success: false, marketId: "" };
}

export const RemoveOrderbookResponse = {
  encode(message: RemoveOrderbookResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.marketId !== "") {
      writer.uint32(18).string(message.marketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RemoveOrderbookResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveOrderbookResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.marketId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveOrderbookResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      marketId: isSet(object.marketId) ? globalThis.String(object.marketId) : "",
    };
  },

  toJSON(message: RemoveOrderbookResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.marketId !== "") {
      obj.marketId = message.marketId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveOrderbookResponse>, I>>(base?: I): RemoveOrderbookResponse {
    return RemoveOrderbookResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveOrderbookResponse>, I>>(object: I): RemoveOrderbookResponse {
    const message = createBaseRemoveOrderbookResponse();
    message.success = object.success ?? false;
    message.marketId = object.marketId ?? "";
    return message;
  },
};

function createBaseUnNormalizeDecimalsRequest(): UnNormalizeDecimalsRequest {
  return { marketId: "", side: "", quantity: "", price: "" };
}

export const UnNormalizeDecimalsRequest = {
  encode(message: UnNormalizeDecimalsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.marketId !== "") {
      writer.uint32(10).string(message.marketId);
    }
    if (message.side !== "") {
      writer.uint32(18).string(message.side);
    }
    if (message.quantity !== "") {
      writer.uint32(26).string(message.quantity);
    }
    if (message.price !== "") {
      writer.uint32(34).string(message.price);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UnNormalizeDecimalsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnNormalizeDecimalsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.marketId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.side = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.quantity = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.price = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnNormalizeDecimalsRequest {
    return {
      marketId: isSet(object.marketId) ? globalThis.String(object.marketId) : "",
      side: isSet(object.side) ? globalThis.String(object.side) : "",
      quantity: isSet(object.quantity) ? globalThis.String(object.quantity) : "",
      price: isSet(object.price) ? globalThis.String(object.price) : "",
    };
  },

  toJSON(message: UnNormalizeDecimalsRequest): unknown {
    const obj: any = {};
    if (message.marketId !== "") {
      obj.marketId = message.marketId;
    }
    if (message.side !== "") {
      obj.side = message.side;
    }
    if (message.quantity !== "") {
      obj.quantity = message.quantity;
    }
    if (message.price !== "") {
      obj.price = message.price;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnNormalizeDecimalsRequest>, I>>(base?: I): UnNormalizeDecimalsRequest {
    return UnNormalizeDecimalsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnNormalizeDecimalsRequest>, I>>(object: I): UnNormalizeDecimalsRequest {
    const message = createBaseUnNormalizeDecimalsRequest();
    message.marketId = object.marketId ?? "";
    message.side = object.side ?? "";
    message.quantity = object.quantity ?? "";
    message.price = object.price ?? "";
    return message;
  },
};

function createBaseUnNormalizeDecimalsResponse(): UnNormalizeDecimalsResponse {
  return {
    baseTokenQuantity: "",
    quoteTokenQuantity: "",
    baseTokenDecimals: 0,
    quoteTokenDecimals: 0,
    pairDecimals: 0,
  };
}

export const UnNormalizeDecimalsResponse = {
  encode(message: UnNormalizeDecimalsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.baseTokenQuantity !== "") {
      writer.uint32(10).string(message.baseTokenQuantity);
    }
    if (message.quoteTokenQuantity !== "") {
      writer.uint32(18).string(message.quoteTokenQuantity);
    }
    if (message.baseTokenDecimals !== 0) {
      writer.uint32(24).uint32(message.baseTokenDecimals);
    }
    if (message.quoteTokenDecimals !== 0) {
      writer.uint32(32).uint32(message.quoteTokenDecimals);
    }
    if (message.pairDecimals !== 0) {
      writer.uint32(40).uint32(message.pairDecimals);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UnNormalizeDecimalsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnNormalizeDecimalsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.baseTokenQuantity = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.quoteTokenQuantity = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.baseTokenDecimals = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.quoteTokenDecimals = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.pairDecimals = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnNormalizeDecimalsResponse {
    return {
      baseTokenQuantity: isSet(object.baseTokenQuantity) ? globalThis.String(object.baseTokenQuantity) : "",
      quoteTokenQuantity: isSet(object.quoteTokenQuantity) ? globalThis.String(object.quoteTokenQuantity) : "",
      baseTokenDecimals: isSet(object.baseTokenDecimals) ? globalThis.Number(object.baseTokenDecimals) : 0,
      quoteTokenDecimals: isSet(object.quoteTokenDecimals) ? globalThis.Number(object.quoteTokenDecimals) : 0,
      pairDecimals: isSet(object.pairDecimals) ? globalThis.Number(object.pairDecimals) : 0,
    };
  },

  toJSON(message: UnNormalizeDecimalsResponse): unknown {
    const obj: any = {};
    if (message.baseTokenQuantity !== "") {
      obj.baseTokenQuantity = message.baseTokenQuantity;
    }
    if (message.quoteTokenQuantity !== "") {
      obj.quoteTokenQuantity = message.quoteTokenQuantity;
    }
    if (message.baseTokenDecimals !== 0) {
      obj.baseTokenDecimals = Math.round(message.baseTokenDecimals);
    }
    if (message.quoteTokenDecimals !== 0) {
      obj.quoteTokenDecimals = Math.round(message.quoteTokenDecimals);
    }
    if (message.pairDecimals !== 0) {
      obj.pairDecimals = Math.round(message.pairDecimals);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnNormalizeDecimalsResponse>, I>>(base?: I): UnNormalizeDecimalsResponse {
    return UnNormalizeDecimalsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnNormalizeDecimalsResponse>, I>>(object: I): UnNormalizeDecimalsResponse {
    const message = createBaseUnNormalizeDecimalsResponse();
    message.baseTokenQuantity = object.baseTokenQuantity ?? "";
    message.quoteTokenQuantity = object.quoteTokenQuantity ?? "";
    message.baseTokenDecimals = object.baseTokenDecimals ?? 0;
    message.quoteTokenDecimals = object.quoteTokenDecimals ?? 0;
    message.pairDecimals = object.pairDecimals ?? 0;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
